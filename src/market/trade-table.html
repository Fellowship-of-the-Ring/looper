<link rel="import" href="../../bower_components/polymer/polymer-element.html">
<!-- <link rel="import" href="../../bower_components/paper-button/paper-button.html"> -->
<dom-module id="trade-table" fit>
    <template>
        <style include="shared-styles">
         :host {
            display: block;
        }

        .long-hash {
            width: 70px;
        }

        .red {
            color: var(--app-red-color);
        }

        .green {
            color: var(--app-green-color);
        }
        </style>
        <global-variable key="app-config" value="{{appConfig}}"></global-variable>
        <!-- The array is set as the <vaadin-grid>'s "items" property -->
        <vaadin-grid aria-label="Basic Binding Example" items="[[orders]]">
            <vaadin-grid-column hidden$="[[hiddenRing]]" width="70px">
                <template class="header">
                    <div class="left-aligned">Ring</div>
                </template>
                <template>
                    <div class="left-aligned">
                        <a href="[[item.ringLink]]"><span class="long-hash">[[item.ringHash]]</span></a>#[[item.ringIndex]]
                    </div>
                </template>
            </vaadin-grid-column>
            <vaadin-grid-column hidden$="[[hiddenOrder]]" width="50px">
                <template class="header">Order</template>
                <template>
                    <div class="left-aligned">
                        <a href="[[item.orderLink]]">
                            <span class="long-hash">[[item.orderHash]]</span>
                        </a>
                    </div>
                </template>
            </vaadin-grid-column>
            <vaadin-grid-column width="50px">
                <template class="header">Type</template>
                <template><span class$="[[item.typeStyle]]"> [[item.buyOrSell]]</span></template>
            </vaadin-grid-column>
            <vaadin-grid-column width="120px">
                <template class="header">
                    <template is="dom-if" if="[[_showInMarket()]]">
                        Sold([[unitS]])
                    </template>
                    <template is="dom-if" if="[[!_showInMarket()]]">
                        Sold
                    </template>
                </template>
                <template>
                    <pretty-number v="[[item.fillAmountS]]" d=[[item.volumnPrecisionS]] postfix="[[item.unitS]]"></pretty-number>
                </template>
            </vaadin-grid-column>
            <vaadin-grid-column hidden$="[[hiddenPrice]]" width="80px">
                <template class="header">Price</template>
                <template>
                    <pretty-number v="[[item.price]]" d=[[item.pricePrecision]]></pretty-number>
                </template>
            </vaadin-grid-column>
            <vaadin-grid-column width="120px">
                <template class="header">
                    <template is="dom-if" if="[[_showInMarket()]]">
                        Bought([[unitB]])
                    </template>
                    <template is="dom-if" if="[[!_showInMarket()]]">
                        Bought
                    </template>
                </template>
                <template>
                    <pretty-number v="[[item.fillAmountB]]" d=[[item.volumnPrecisionB]] postfix="[[item.unitB]]"></pretty-number>
                </template>
            </vaadin-grid-column>
            <vaadin-grid-column width="90px">
                <template class="header">Lrc-Fee</template>
                <template>
                    <pretty-number v="[[item.feeLrc]]" d=[[appConfig.lrc.precision]]></pretty-number>
                </template>
            </vaadin-grid-column>
            <vaadin-grid-column width="90px">
                <template class="header">Margin-Split</template>
                <template>
                    <pretty-number v="[[item.marginSplit]]" d=[[item.marginSplitPrecision]] postfix="[[item.marginSplitUnit]]"></pretty-number>
                </template>
            </vaadin-grid-column>
            <vaadin-grid-column hidden$="[[hiddenTime]]" width="100px">
                <template class="header">Time</template>
                <template>
                    <time-str seconds="[[item.timestamp]]"></time-str>
                </template>
            </vaadin-grid-column>
            <paper-progress indeterminate disabled$="{{!loading}}" class="data-loading"></paper-progress>
            <iron-ajax auto id="ajax" url="https://raw.githubusercontent.com/Loopring/mock-relay-data/master/orderFills.json" handle-as="json" last-response="{{resp}}" loading="{{loading}}"></iron-ajax>
        </vaadin-grid>
    </template>
    <script>
    class TradeTable extends Polymer.Element {
        static get is() {
            return 'trade-table';
        }

        constructor() {
            super();
        }

        /**
         *  subType: oneof:[order, ring, market]
         * market: lrc-eos
         */
        static get properties() {
            return {
                token: {
                    type: String,
                },
                subType: {
                    type: String
                },
                market: {
                    type: String
                },
                orders: {
                    type: Object,
                    computed: '_computeOrders(appConfig, resp)'
                }
            };
        }

        ready() {
            super.ready();
            if (this.subType) {
                let subType = this.subType.toLowerCase();
                this.hiddenPrice = true;
                if ("ring" === subType) {
                    this.hiddenRing = true;
                    this.hiddenTime = true;
                }
                if ("order" === subType) {
                    this.hiddenOrder = true;
                }
                if ("market" === subType) {}
            }
        }

        _showInMarket() {
            return this.market;
        }

        _computOrderItem(appConfig, item) {
            if (item && appConfig) {
                const defaultPricePrecision = 3;
                const defaultVolumePrecision = 5;
                item.pricePrecision = defaultPricePrecision;
                item.volumnPrecisionS = defaultVolumePrecision;
                item.volumnPrecisionB = defaultVolumePrecision;
                item.ringLink = "#/ring/" + item.ringHash;
                item.orderLink = "#/order/" + item.orderHash;
                item.txLink = "https://etherscan.io/tx/" + item.txHash;
                if (this.market) {
                    let marketConfig = appConfig.getMarket(this.market);
                    this.unitS = appConfig.tokenMap[marketConfig.tokenx].unit;
                    this.unitB = appConfig.tokenMap[marketConfig.tokeny].unit;
                    item.typeStyle = item.tokenS === marketConfig.tokenx ? 'red' : 'green';
                    item.buyOrSell = item.tokenS === marketConfig.tokenx ? "Sell" : "Buy";
                    this._computePrecisionInMarket(item, marketConfig, appConfig);
                } else {
                    item.buyOrSell = item.tokenS + "â‡¢" + item.tokenB;
                    this._computePrecision(item, appConfig)
                }
                item.fillAmountS = Number(item.fillAmountS);
                item.fillAmountB = Number(item.fillAmountB);
                item.fee = Number(item.fee);
                item.price = this.calPrice(item.fillAmountB, item.fillAmountS);
                item.feeLrc = Number(item.feeLrc);
                let marginSplitToken = appConfig.tokenMap[item.marginSplitToken.toUpperCase()];
                item.marginSplit = Number(item.marginSplit);
                item.marginSplitUnit = marginSplitToken.unit;
                item.marginSplitPrecision = marginSplitToken.precision;
                return item;
            }
        }

        _computePrecisionInMarket(item, marketConfig, appConfig) {
            const defaultPricePrecision = 3;
            const defaultVolumePrecision = 5;
            if (item.tokenB === marketConfig.tokenx) {
                let tempS = item.tokenS,
                    tempB = item.tokenB,
                    tempAmountS = item.fillAmountS,
                    tempAmountB = item.fillAmountB;
                item.tokenS = tempB;
                item.fillAmountS = tempAmountB;
                item.tokenB = tempS;
                item.fillAmountB = tempAmountS;
            }
            item.pricePrecision = marketConfig.pricePrecision;
            const tokenxConfigS = appConfig.tokenMap[item.tokenS];
            if (tokenxConfigS) {
                item.volumnPrecisionS = tokenxConfigS.precision;
            } else {
                item.volumnPrecisionS = defaultVolumePrecision;
            }
            const tokenxConfigB = appConfig.tokenMap[item.tokenB];
            if (tokenxConfigB) {
                item.volumnPrecisionB = tokenxConfigB.precision;
            } else {
                item.volumnPrecisionB = defaultVolumePrecision;
            }
        }

        _computePrecision(item, appConfig) {
            let precisionS = this._fillMarket(item.tokenS, appConfig);
            item.volumnPrecisionS = precisionS.pricePrecision;
            item.pricePrecision = precisionS.pricePrecision;
            const tokenSConfig = appConfig.tokenMap[item.tokenS.toUpperCase()];
            if (tokenSConfig) {
                item.unitS = tokenSConfig.unit;
            } else {
                item.unitS = "";
            }
            let precisionB = this._fillMarket(item.tokenB, appConfig)
            item.volumnPrecisionB = precisionB.pricePrecision;
            const tokenBConfig = appConfig.tokenMap[item.tokenB];
            if (tokenBConfig) {
                item.unitB = tokenBConfig.unit;
            } else {
                item.unitB = "";
            }
        }

        _fillMarket(tokenName, appConfig) {
            const defaultPricePrecision = 3;
            const defaultVolumePrecision = 5;
            const marketConfig = appConfig.marketMap[tokenName.toUpperCase() + "-WETH"];
            let pricePrecision = defaultPricePrecision,
                volumnPrecision = defaultVolumePrecision
            if (marketConfig) {
                pricePrecision = marketConfig.pricePrecision;
                const tokenxConfig = appConfig.tokenMap[tokenName];
                if (tokenxConfig) {
                    volumnPrecision = tokenxConfig.precision;
                } else {
                    volumnPrecision = defaultVolumePrecision;
                }
            }
            return { pricePrecision: pricePrecision, volumnPrecision: volumnPrecision }
        }

        _computeOrders(appConfig, resp) {
            if (resp && appConfig) {
                return _.map(resp.result.data, o => this._computOrderItem(appConfig, o));
            }
        }

        calPrice(b, s) {
            if (b && s && s !== 0) {
                return (b / s);
            }
            return 0;
        }

        typeStyle(isBuy) {
            return isBuy ? 'var(--app-green-color)' : 'var(--app-red-color)';
        }

        getType(isBuy) {
            return isBuy ? 'Buy' : 'Sell';
        }

        go() {
            this.$.ajax.generateRequest();
        }
    }

    window.customElements.define(TradeTable.is, TradeTable);
    </script>
</dom-module>